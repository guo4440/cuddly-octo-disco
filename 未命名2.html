<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Three.js è²æ§å‹•æ…‹çµæ§‹ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        .dg.main { pointer-events: auto; } 
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 18px;
            pointer-events: none;
            text-shadow: 0 0 5px #00FFBB;
            z-index: 10;
        }
        .status-ready { color: #00FFBB; }
        .status-error { color: #FF4444; }
    </style>
</head>
<body>
    <div id="info">
        ğŸ¤ **æ­£åœ¨ç­‰å¾…éº¥å…‹é¢¨æ¬Šé™...** | ğŸ–±ï¸ **æ‹–æ›³**æ»‘é¼ : ç’°ç¹ | **ç§»å‹•é¼ æ¨™**: è¦–è¦ºä¸­å¿ƒé»è·Ÿéš¨ä¸”ç·šæ¢å›é¥‹å¾‹å‹•
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>

    <script>
        // --- æ ¸å¿ƒè®Šæ•¸åˆå§‹åŒ– ---
        let scene, camera, renderer, controls;
        let raycaster;
        let mouse = new THREE.Vector2();

        let lines = [];
        let lineGeometry;
        let lineMesh; 

        let positionAttribute, colorAttribute;
        let allPositions = [];
        let allColors = [];

        // çµæ§‹è®Šæ•¸
        const initialRadius = 80;
        const maxRadiusScale = 1.8; // ç·šæ¢æœ€å¤§æ”¾å¤§å€æ•¸
        let mouse3D = new THREE.Vector3(0, 0, 0); // æ»‘é¼ åœ¨ 3D ç©ºé–“çš„æŠ•å½±é»

        // --- Web Audio è®Šæ•¸ ---
        let audioContext;
        let analyser;
        let dataArray;
        let volume = 0; // ç•¶å‰éŸ³é‡ (0.0 - 1.0)

        // åƒæ•¸æ§åˆ¶ç‰©ä»¶
        const params = {
            lineCount: 150,
            lineWidth: 10, // æœ€å¤§å€¼è¨­ç½®ç‚º 10 
            baseColor: '#3333AA',
            hoverColor: '#FF88FF',
            hoverAmplitude: 8, 
            structureRadius: initialRadius, 
            mouseFollowStrength: 0.05,
            baseRotationSpeed: 0.0005, // åŸºç¤è‡ªæ—‹é€Ÿåº¦
            rotationAmplitude: 0.015, // éŸ³é‡æœ€å¤§æ™‚é¡å¤–å¢åŠ çš„æ—‹è½‰å¹…åº¦
            micSensitivity: 2.0, // éº¥å…‹é¢¨åæ‡‰éˆæ•åº¦
            resetScene: () => { initLines(true); }
        };
        
        // é¡è‰²å®šç¾©
        let BASE_COLOR = new THREE.Color(params.baseColor); 
        let HOVER_COLOR = new THREE.Color(params.hoverColor); 
        
        // å¾‹å‹•ç›¸é—œ
        let lineHoverStrengths = []; 
        const EXPLOSION_VELOCITY_SCALAR = 150; 
        
        // --- I. Three.js è¨­ç½® ---
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.005);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 100);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            raycaster = new THREE.Raycaster();
            raycaster.params.Line = { threshold: 3 }; 
            
            initLines(false);
            initGUI();
            initAudio(); // å•Ÿå‹•éŸ³è¨Š

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousemove', onMouseMove, false);

            animate();
        }

        // --- II. dat.GUI è¨­ç½® ---
        function initGUI() {
            const gui = new dat.GUI();

            const folderAppearance = gui.addFolder('å¤–è§€èˆ‡æ•¸é‡');
            folderAppearance.add(params, 'lineCount', 50, 500).step(10).name('ç·šæ¢æ•¸é‡');
            folderAppearance.add(params, 'lineWidth', 1, 10).step(1).name('ç·šæ¢ç²—ç´° (è¨»)');
            folderAppearance.add(params, 'structureRadius', 10, 200).step(10).name('çµæ§‹åŠå¾‘ (åˆå§‹)');
            folderAppearance.addColor(params, 'baseColor').name('åŸºç¤é¡è‰²');
            folderAppearance.addColor(params, 'hoverColor').name('æ‡¸åœé¡è‰²');
            folderAppearance.add(params, 'hoverAmplitude', 1, 30).step(1).name('å¾‹å‹•å¹…åº¦');
            folderAppearance.open();

            const folderMotion = gui.addFolder('é£„ç§»èˆ‡æ—‹è½‰æ§åˆ¶');
            folderMotion.add(params, 'mouseFollowStrength', 0.01, 0.2).step(0.01).name('é¼ æ¨™è·Ÿéš¨å¼·åº¦');
            folderMotion.add(params, 'baseRotationSpeed', 0.0, 0.005).step(0.0001).name('åŸºç¤è‡ªæ—‹é€Ÿåº¦');
            folderMotion.add(params, 'rotationAmplitude', 0.001, 0.05).step(0.001).name('è²æ§æ—‹è½‰å¹…åº¦');
            folderMotion.open();
            
            const folderAudio = gui.addFolder('éŸ³è¨Šåµæ¸¬');
            folderAudio.add(params, 'micSensitivity', 0.5, 5.0).step(0.1).name('éº¥å…‹é¢¨éˆæ•åº¦');
            folderAudio.open();

            const folderControls = gui.addFolder('å ´æ™¯æ§åˆ¶');
            folderControls.add(params, 'resetScene').name('æ‡‰ç”¨è®Šæ›´/é‡ç½®å ´æ™¯');
            folderControls.open();
        }
        
        // --- III. éº¥å…‹é¢¨éŸ³è¨Šè™•ç† ---
        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256; 
            analyser.smoothingTimeConstant = 0.85;
            const bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
            
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    const source = audioContext.createMediaStreamSource(stream);
                    source.connect(analyser);
                    document.getElementById('info').innerHTML = '<span class="status-ready">ğŸ¤ **éº¥å…‹é¢¨å·²å•Ÿå‹•**</span> | ğŸ–±ï¸ **æ‹–æ›³**æ»‘é¼ : ç’°ç¹ | **ç§»å‹•é¼ æ¨™**: è¦–è¦ºä¸­å¿ƒé»è·Ÿéš¨ä¸”ç·šæ¢å›é¥‹å¾‹å‹•';
                })
                .catch(err => {
                    console.error('ç„¡æ³•å–å¾—éº¥å…‹é¢¨æ¬Šé™: ', err);
                    document.getElementById('info').innerHTML = '<span class="status-error">âŒ **éº¥å…‹é¢¨æ¬Šé™è¢«æ‹’çµ•æˆ–ä¸æ”¯æŒ**</span> | ğŸ–±ï¸ **æ‹–æ›³**æ»‘é¼ : ç’°ç¹ | **ç§»å‹•é¼ æ¨™**: é„°è¿‘ç·šæ¢è®Šè‰²èˆ‡å¾‹å‹•';
                });
        }
        
        function updateAudio() {
            if (!analyser) return;

            analyser.getByteFrequencyData(dataArray);
            
            // è¨ˆç®— RMS (å‡æ–¹æ ¹) ä½œç‚ºæ•´é«”éŸ³é‡
            let sumOfSquares = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sumOfSquares += dataArray[i] * dataArray[i];
            }
            // æ­¸ä¸€åŒ–éŸ³é‡ (0 åˆ° 1)
            let rms = Math.sqrt(sumOfSquares / dataArray.length) / 128; 
            
            // æ‡‰ç”¨éˆæ•åº¦å’Œè¡°æ¸›ï¼Œä½¿è¦–è¦ºæ•ˆæœæ›´æµæš¢
            const targetVolume = Math.min(rms * params.micSensitivity, 1.0);
            volume += (targetVolume - volume) * 0.15; // å¹³æ»‘éæ¸¡
        }

        // --- IV. ç·šæ¢åˆå§‹åŒ–/é‡ç½® (åŒå‰) ---
        function initLines(isReset) {
            if (isReset && lineMesh) {
                scene.remove(lineMesh);
                lineMesh.geometry.dispose();
                lines = [];
                allPositions = [];
                allColors = [];
                lineHoverStrengths = [];
            }
            
            BASE_COLOR.set(params.baseColor);
            HOVER_COLOR.set(params.hoverColor);

            const R = params.structureRadius;
            const R_Inner = R * 0.5;

            for (let i = 0; i < params.lineCount; i++) {
                const phi1 = Math.acos(2 * Math.random() - 1); 
                const theta1 = Math.random() * 2 * Math.PI;    
                const phi2 = Math.acos(2 * Math.random() - 1);
                const theta2 = Math.random() * 2 * Math.PI;

                const p1 = new THREE.Vector3().setFromSphericalCoords(R, phi1, theta1);
                const p4 = new THREE.Vector3().setFromSphericalCoords(R, phi2, theta2);
                const p2 = p1.clone().multiplyScalar(R_Inner / R);
                const p3 = p4.clone().multiplyScalar(R_Inner / R);

                p2.x += (Math.random() - 0.5) * 5;
                p3.y += (Math.random() - 0.5) * 5;

                const curve = new THREE.CatmullRomCurve3([p1, p2, p3, p4]);
                const points = curve.getPoints(30); 
                
                const color = BASE_COLOR.clone().offsetHSL(0, 0, Math.random() * 0.2);

                for (let j = 0; j < 30; j++) {
                    allPositions.push(points[j].x, points[j].y, points[j].z);
                    allColors.push(color.r, color.g, color.b);
                }

                lines.push({
                    originalPoints: points.map(p => p.clone()),
                    points: points,
                    curveSegments: 30,
                    lineIndexStart: (allPositions.length / 3) - 30, 
                    motionOffset: Math.random() * Math.PI * 2,
                    randomDirection: new THREE.Vector3((Math.random() - 0.5) * EXPLOSION_VELOCITY_SCALAR, (Math.random() - 0.5) * EXPLOSION_VELOCITY_SCALAR, (Math.random() - 0.5) * EXPLOSION_VELOCITY_SCALAR).normalize()
                });
                
                lineHoverStrengths.push(0);
            }

            lineGeometry = new THREE.BufferGeometry();
            positionAttribute = new THREE.Float32BufferAttribute(allPositions, 3);
            colorAttribute = new THREE.Float32BufferAttribute(allColors, 3);
            lineGeometry.setAttribute('position', positionAttribute);
            lineGeometry.setAttribute('color', colorAttribute);
            
            const baseMaterial = new THREE.LineBasicMaterial({
                vertexColors: true,
                linewidth: params.lineWidth,
                transparent: true,
                opacity: 0.9,
            });

            const indices = [];
            let currentLineIndex = 0;
            lines.forEach(line => {
                for (let j = 0; j < line.curveSegments - 1; j++) {
                    indices.push(currentLineIndex + j, currentLineIndex + j + 1);
                }
                currentLineIndex += line.curveSegments;
            });
            lineGeometry.setIndex(indices);

            lineMesh = new THREE.LineSegments(lineGeometry, baseMaterial);
            scene.add(lineMesh);
        }

        // --- V. å‹•ç•«èˆ‡æ›´æ–°è¿´åœˆ ---
        function animate() {
            requestAnimationFrame(animate);

            updateAudio(); 
            updateLineAnimation(); 
            checkHoverPropagation(); 
            
            // è²æ§æ—‹è½‰ï¼šåŸºç¤é€Ÿåº¦ + éŸ³é‡æŒ¯å¹…
            const currentRotationSpeed = params.baseRotationSpeed + volume * params.rotationAmplitude;
            lineMesh.rotation.y += currentRotationSpeed;
            
            controls.update(); 
            renderer.render(scene, camera);
        }

        function updateLineAnimation() {
            const positions = positionAttribute.array;
            const time = performance.now() * 0.001;
            
            // è²æ§ç¸®æ”¾ï¼šæ ¹æ“šéŸ³é‡è¨ˆç®—æ”¾å¤§ä¿‚æ•¸ (1.0 åˆ° maxRadiusScale)
            const volumeScale = 1.0 + volume * (maxRadiusScale - 1.0);

            lines.forEach((line, i) => {
                const hoverStrength = lineHoverStrengths[i];
                
                // æ»‘é¼ é è¿‘å¾‹å‹•
                const hoverMotion = Math.sin(time * 15 + line.motionOffset * 2) * params.hoverAmplitude * hoverStrength;
                const totalMotion = hoverMotion; 
                
                for (let j = 0; j < line.curveSegments; j++) {
                    const originalPoint = line.originalPoints[j];
                    const currentPoint = line.points[j];
                    
                    // 1. æ‡‰ç”¨è²æ§ç¸®æ”¾ï¼šç·šæ¢çµæ§‹å¾ä¸­å¿ƒæ”¾å¤§/ç¸®å°
                    const scaledPoint = originalPoint.clone().multiplyScalar(volumeScale);
                    
                    // 2. æ‡‰ç”¨é¼ æ¨™é£„ç§»ï¼šå°‡ç¸®æ”¾å¾Œçš„é»å¹³ç§»åˆ°ä»¥ mouse3D ç‚ºä¸­å¿ƒ
                    const offset = scaledPoint; 
                    currentPoint.copy(mouse3D).add(offset);
                    
                    // 3. ç–ŠåŠ æ»‘é¼ å¾‹å‹• (åœ¨é£„ç§»å¾Œçš„é»ä¸Šç–ŠåŠ )
                    if (totalMotion > 0.01) { 
                        currentPoint.add(line.randomDirection.clone().multiplyScalar(totalMotion));
                    }

                    // 4. æ›´æ–° Buffer
                    const globalIndex = (line.lineIndexStart + j) * 3;
                    currentPoint.toArray(positions, globalIndex);
                }
            });

            positionAttribute.needsUpdate = true;
        }

        // --- VI. è¼”åŠ©å‡½å¼ (æ»‘é¼ è·Ÿéš¨/é¡è‰²/å¾‹å‹•åµæ¸¬) ---
        function getMouse3DPosition() {
            raycaster.setFromCamera(mouse, camera);
            
            const targetPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(
                camera.position.clone().normalize().negate(), 
                controls.target
            ); 
            
            const intersection = new THREE.Vector3();
            if (raycaster.ray.intersectPlane(targetPlane, intersection)) {
                return intersection;
            }
            return controls.target; 
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            
            const targetMouse3D = getMouse3DPosition();
            mouse3D.lerp(targetMouse3D, params.mouseFollowStrength);
        }

        function checkHoverPropagation() {
            raycaster.setFromCamera(mouse, camera);
            const colors = colorAttribute.array;
            let closestLineIndex = -1;
            const intersects = raycaster.intersectObject(lineMesh);
            if (intersects.length > 0) {
                const intersect = intersects[0];
                const lineIndex = lines.findIndex(line => {
                    return intersect.index >= line.lineIndexStart && intersect.index < line.lineIndexStart + line.curveSegments;
                });
                if (lineIndex !== -1) { closestLineIndex = lineIndex; }
            }
            lines.forEach((line, i) => {
                let colorMixFactor = 0; let motionStrength = 0; 
                if (closestLineIndex !== -1) {
                    const mid1 = lines[closestLineIndex].points[Math.floor(lines[closestLineIndex].points.length / 2)];
                    const mid2 = line.points[Math.floor(line.points.length / 2)];
                    const distance = mid1.distanceTo(mid2);
                    const influenceRadius = 40;
                    const falloff = 1.0 - Math.min(distance / influenceRadius, 1.0);
                    colorMixFactor = Math.pow(falloff, 2.5); 
                    motionStrength = Math.pow(falloff, 1.5); 
                }
                lineHoverStrengths[i] = motionStrength;
                const targetColor = BASE_COLOR.clone().lerp(HOVER_COLOR, colorMixFactor);
                for (let j = 0; j < line.curveSegments; j++) {
                    const globalIndex = (line.lineIndexStart + j) * 3;
                    targetColor.toArray(colors, globalIndex);
                }
            });
            colorAttribute.needsUpdate = true;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- å•Ÿå‹•ç¨‹å¼ ---
        initThree();
    </script>
</body>
</html>